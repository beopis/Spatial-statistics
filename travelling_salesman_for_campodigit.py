# -*- coding: utf-8 -*-
"""tempi percorrenza agricoltori - CampoDigitale.ipynb

Automatically generated by Colab.
"""

!pip install ortools

from __future__ import print_function
import urllib, json
import requests
import sys
import numpy as np
from ortools.constraint_solver import routing_enums_pb2
from ortools.constraint_solver import pywrapcp
import urllib.parse

apikey = "....."  # enter api key

"""## Funzioni Geolocalizzazione"""

def to_be_visited():
  global visited_and_distance
  v = -10

  # Choosing the vertex with the minimum distance
  for index in range(number_of_vertices):

    if visited_and_distance[index][0] == 0 \
      and (v < 0 or visited_and_distance[index][1] <= \
      visited_and_distance[v][1]):
        v = index

  return v

def geocode(address):

    QUERY_GEOCODE = 'https://api.openrouteservice.org/geocode/search?api_key=' + apikey + '&text='

    try:
      # Send request
      r = requests.get(url=QUERY_GEOCODE + urllib.parse.quote(address, safe=''))
      data = r.json()

      return data["features"][0]["geometry"]["coordinates"]

    except:
      return None

"""## Preleva coordinate geografiche e matrice distanze"""

treviso = [
    "1 Darth Vader Street 12345 Black Death (UN)", 
    "2 Sauron Square 54321 Mordor (ME)",
    "3 Joker Street 12321 Gotham City (DC)"]

######## Geocoding

coordinates = []
x = 0

for address in treviso: #addresses:
    coordinates.append(geocode(address))
    print(str(round(x / len(treviso) * 100)) + "%") #len(addresses) * 100)) + "%")
    x += 1

print("Data dumped")

######## Matrix distances

r = requests.post('https://api.openrouteservice.org/v2/matrix/driving-car', json = {
    "locations": coordinates
}, headers = {
    "Authorization":apikey
})

"""## Imposta il modello per l'algoritmo di Google"""

route = []

def create_data_model():
    """Stores the data for the problem."""
    data = {}

    # From edges before
    data['distance_matrix'] = r.json()["durations"]

    data['num_vehicles'] = 1
    data['depot'] = 0
    return data


def print_solution(manager, routing, solution):
    """Prints solution on console."""
    #print('Objective: {} miles'.format(solution.ObjectiveValue()))
    index = routing.Start(0)
    plan_output = 'Route for vehicle 0:\n'
    route_distance = 0
    while not routing.IsEnd(index):

        # Next node
        route_node = manager.IndexToNode(index)
        route.append(route_node)

        # Next ind
        previous_index = index
        index = solution.Value(routing.NextVar(index))
        route_distance += routing.GetArcCostForVehicle(previous_index, index, 0)

    route.append(manager.IndexToNode(index))

def main():
    """Entry point of the program."""
    # Instantiate the data problem.
    data = create_data_model()

    # Create the routing index manager.
    manager = pywrapcp.RoutingIndexManager(len(data['distance_matrix']),
                                           data['num_vehicles'], data['depot'])

    # Create Routing Model.
    routing = pywrapcp.RoutingModel(manager)


    def distance_callback(from_index, to_index):
        """Returns the distance between the two nodes."""
        # Convert from routing variable Index to distance matrix NodeIndex.
        from_node = manager.IndexToNode(from_index)
        to_node = manager.IndexToNode(to_index)
        return data['distance_matrix'][from_node][to_node]

    transit_callback_index = routing.RegisterTransitCallback(distance_callback)

    # Define cost of each arc.
    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)

    # Setting first solution heuristic.
    search_parameters = pywrapcp.DefaultRoutingSearchParameters()
    search_parameters.first_solution_strategy = (
        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC)

    # Solve the problem.
    solution = routing.SolveWithParameters(search_parameters)

    # Print solution on console.
    if solution:
        print_solution(manager, routing, solution)

        print("\n\nOrdine degli indirizzi da visitare:\n")
        for node in route:
          print(addresses[node])

if __name__ == '__main__':
    main()

